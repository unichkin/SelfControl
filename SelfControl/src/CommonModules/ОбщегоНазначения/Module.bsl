
#Область ПрограммныйИнтерфейс

// Вычисляет контрольную сумму для произвольных данных по указанному алгоритму.
//
// Параметры:
//  Данные   - Произвольный - любое сериализуемое значение.
//  Алгоритм - ХешФункция   - алгоритм расчета контрольной суммы. По умолчанию, MD5.
//
// Возвращаемое значение:
//  Строка - контрольная сумма строкой без пробелов (например 32 символа).
//
Функция КонтрольнаяСуммаСтрокой(Знач Данные, Знач Алгоритм = Неопределено) Экспорт

	Если Алгоритм = Неопределено Тогда
		Алгоритм = ХешФункция.MD5;
	КонецЕсли;

	ХешированиеДанных = Новый ХешированиеДанных(Алгоритм);
	Если ТипЗнч(Данные) <> Тип("Строка") И ТипЗнч(Данные) <> Тип("ДвоичныеДанные") Тогда
		Данные = ЗначениеВСтрокуXML(Данные);
	КонецЕсли;
	ХешированиеДанных.Добавить(Данные);

	Если ТипЗнч(ХешированиеДанных.ХешСумма) = Тип("ДвоичныеДанные") Тогда
		Результат = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	ИначеЕсли ТипЗнч(ХешированиеДанных.ХешСумма) = Тип("Число") Тогда
		Результат = Формат(ХешированиеДанных.ХешСумма, "ЧГ=");
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Преобразует (сериализует) любое значение в XML-строку.
// Преобразованы в могут быть только те объекты, для которых в синтакс-помощнике указано, что они сериализуются.
// См. также ЗначениеИзСтрокиXML.
//
// Параметры:
//  Значение - Произвольный - значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//  Строка - XML-строка.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт

	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);

	Возврат ЗаписьXML.Закрыть();
КонецФункции

Функция ЗначениеКонстанты(ИмяКонстанты, ПолучатьДанныеХранилища = Ложь) Экспорт
	Менеджер = Константы[ИмяКонстанты];
	ЗначениеКонстанты = Менеджер.Получить();
	Если ПолучатьДанныеХранилища И ТипЗнч(ЗначениеКонстанты) = Тип("ХранилищеЗначения") Тогда
		ЗначениеКонстанты  = ЗначениеКонстанты.Получить();
		Если ЗначениеКонстанты = Неопределено Тогда
			ЗначениеКонстанты = Менеджер.СоздатьМенеджерЗначения().ЗначениеПоУмолчанию();

		КонецЕсли;
	КонецЕсли;

	Возврат ЗначениеКонстанты;

КонецФункции

Процедура ЗаписатьКонстанту(ИмяКонстанты, Значение, ВХранилище = Ложь, ОбновитьПовтИсп = Ложь) Экспорт
	Менеджер = Константы[ИмяКонстанты];

	Если ВХранилище Тогда
		ЗначениеКонстанты = Новый ХранилищеЗначения(Значение, Новый СжатиеДанных(9));
	Иначе
		ЗначениеКонстанты = Значение;
	КонецЕсли;
	Менеджер.Установить(ЗначениеКонстанты);

	Если ОбновитьПовтИсп Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;

КонецПроцедуры

// Структура, содержащая значения реквизитов, прочитанные из информационной базы по ссылке на объект.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//                       требований к свойствам структуры.
//                       Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//                       к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя, и в случае,
//                                    - если есть ограничение на уровне записей, то все реквизиты вернутся
//                                      со значением Неопределено;
//                                    - если нет прав для работы с таблицей, то возникнет исключение.
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//            - если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//            - если в параметр Ссылка передана пустая ссылка, то возвращается структура,
//              соответствующая именам реквизитов со значениями Неопределено.
//            - если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка),
//              то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь) Экспорт

	Попытка
		ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя();
	Исключение
		ВызватьИсключение НСтр("ru = 'Неверный первый параметр Ссылка:
		                             |- Значение должно быть ссылкой или именем предопределенного элемента'");
	КонецПопытки;
	// Разбор реквизитов, если второй параметр Строка.
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;

		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
	КонецЕсли;

	// Приведение реквизитов к единому формату.
	СтруктураПолей = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда

		СтруктураПолей = Реквизиты;

	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда

		Для Каждого Реквизит Из Реквизиты Цикл

			Попытка
				ПсевдонимПоля = СтрЗаменить(Реквизит, ".", "");
				СтруктураПолей.Вставить(ПсевдонимПоля, Реквизит);
			Исключение
				// Если псевдоним не является ключом.

				// Поиск ошибки доступности полей.
				Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
				Если Результат.Ошибка Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Неверный второй параметр Реквизиты: %1'"), Результат.ОписаниеОшибки);
				КонецЕсли;

				// Не удалось распознать ошибку, проброс первичной ошибки.
				ВызватьИсключение;

			КонецПопытки;
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;

	// Подготовка результата (после выполнения запроса переопределится).
	Результат = Новый Структура;

	// Формирование текста запроса к выбираемым полям.
	ТекстЗапросаПолей = "";
	Для каждого КлючИЗначение Из СтруктураПолей Цикл

		ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
		ПсевдонимПоля = КлючИЗначение.Ключ;

		ТекстЗапросаПолей =
			ТекстЗапросаПолей + ?(ПустаяСтрока(ТекстЗапросаПолей), "", ",") + "
			|	" + ИмяПоля + " КАК " + ПсевдонимПоля;


		// Предварительное добавление поля по псевдониму в возвращаемый результат.
		Результат.Вставить(ПсевдонимПоля);

	КонецЦикла;

	// Если предопределенного нет в ИБ.
	// - приведение результата к отсутствию объекта в ИБ или передаче пустой ссылки.
	Если Ссылка = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;

	ТекстЗапроса =
		"ВЫБРАТЬ " + ?(ВыбратьРазрешенные, "РАЗРЕШЕННЫЕ", "") + "
		|" + ТекстЗапросаПолей + "
		|ИЗ
		|	" + ПолноеИмяОбъектаМетаданных + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка
		|";

	// Выполнение запроса.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст = ТекстЗапроса;

	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение

		// Если реквизиты были переданы строкой, то они уже конвертированы в массив.
		// Если реквизиты - массив, оставляем без изменений.
		// Если реквизиты - структура - конвертируем в массив.
		// В остальных случаях уже было бы выброшено исключение.
		Если Тип("Структура") = ТипЗнч(Реквизиты) Тогда
			Реквизиты = Новый Массив;
			Для каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Реквизиты.Добавить(ИмяПоля);
			КонецЦикла;
		КонецЕсли;

		// Поиск ошибки доступности полей.
		Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр Реквизиты: %1'"), Результат.ОписаниеОшибки);
		КонецЕсли;

		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;

	КонецПопытки;

	// Заполнение реквизитов.
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Значение реквизита, прочитанного из информационной базы по ссылке на объект.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  ИмяРеквизита       - Строка - имя получаемого реквизита.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя, и в случае,
//                                    - если есть ограничение на уровне записей, то возвращается Неопределено;
//                                    - если нет прав для работы с таблицей, то возникнет исключение.
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Произвольный - зависит от типа значения прочитанного реквизита.
//               - если в параметр Ссылка передана пустая ссылка, то возвращается Неопределено.
//               - если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка),
//                 то возвращается Неопределено.
//
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные = Ложь) Экспорт

	Если ПустаяСтрока(ИмяРеквизита) Тогда
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр ИмяРеквизита:
		                             |- Имя реквизита должно быть заполнено'");
	КонецЕсли;

	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];

КонецФункции

// Значения реквизитов, прочитанные из информационной базы для нескольких объектов.
//
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылки - Массив - массив ссылок на объекты одного типа.
//                          Значения массива должны быть ссылками на объекты одного типа.
//                          если массив пуст, то результатом будет пустое соответствие.
//  Реквизиты - Строка - имена реквизитов перечисленные через запятую, в формате требований к свойствам
//                             структуры. Например, "Код, Наименование, Родитель".
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя, и в случае,
//                                    - если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                      будет исключен и из результата;
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Соответствие - список объектов и значений их реквизитов:
//   * Ключ - ЛюбаяСсылка - ссылка на объект;
//   * Значение - Структура - значения реквизитов:
//    ** Ключ - Строка - имя реквизита;
//    ** Значение - Произвольный - значение реквизита.
//
Функция ЗначенияРеквизитовОбъектов(Ссылки, Знач Реквизиты, ВыбратьРазрешенные = Ложь) Экспорт

	Если ПустаяСтрока(Реквизиты) Тогда
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр Реквизиты:
		                             |- Поле объекта должно быть указано'");
	КонецЕсли;

	Если СтрНайти(Реквизиты, ".") <> 0 Тогда
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр Реквизиты:
		                             |- Обращение через точку не поддерживается'");
	КонецЕсли;

	ЗначенияРеквизитов = Новый Соответствие;
	Если Ссылки.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;

	ПерваяСсылка = Ссылки[0];

	Попытка
		ПолноеИмяОбъектаМетаданных = ПерваяСсылка.Метаданные().ПолноеИмя();
	Исключение
		ВызватьИсключение НСтр("ru = 'Неверный первый параметр Ссылки:
		                             |- Значения массива должны быть ссылками'");
	КонецПопытки;

	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ " + ?(ВыбратьРазрешенные, "РАЗРЕШЕННЫЕ", "") + "
		|	Ссылка КАК Ссылка, " + Реквизиты + "
		|ИЗ
		|	" + ПолноеИмяОбъектаМетаданных + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&Ссылки)";
	Запрос.УстановитьПараметр("Ссылки", Ссылки);

	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение

		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");

		// Поиск ошибки доступности полей.
		Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неверный второй параметр Реквизиты: %1'"), Результат.ОписаниеОшибки);
		КонецЕсли;

		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;

	КонецПопытки;

	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(Реквизиты);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;

	Возврат ЗначенияРеквизитов;

КонецФункции

// Значения реквизита, прочитанного из информационной базы для нескольких объектов.
//
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  МассивСсылок       - Массив - массив ссылок на объекты одного типа.
//                                Значения массива должны быть ссылками на объекты одного типа.
//  ИмяРеквизита       - Строка - например, "Код".
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя, и в случае,
//                                    - если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                      будет исключен и из результата;
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
//      * Ключ     - ссылка на объект,
//      * Значение - значение прочитанного реквизита.
//
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита, ВыбратьРазрешенные = Ложь) Экспорт

	Если ПустаяСтрока(ИмяРеквизита) Тогда
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр ИмяРеквизита:
		                             |- Имя реквизита должно быть заполнено'");
	КонецЕсли;

	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита, ВыбратьРазрешенные);
	Для каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;

	Возврат ЗначенияРеквизитов;

КонецФункции

Процедура УдалитьСтрокиКоллекции(Коллекция, ИмяФлаговойКолонки = "Удалить", ЗначениеФлаговойКолонки = Истина, УдалитьФлаговуюКолонку = Истина) Экспорт

	Поиск = Новый Структура(ИмяФлаговойКолонки, ЗначениеФлаговойКолонки);
	ТипКоллекции = ТипЗнч(Коллекция);

	Если ТипКоллекции = Тип("ТаблицаЗначений")
		ИЛИ Найти("" + ТипКоллекции, "табличная часть") > 0 Тогда
		МассивСтрокКУдалению = Коллекция.НайтиСтроки(Поиск);
		Для каждого УдаляемаяСтрока Из МассивСтрокКУдалению Цикл
			Коллекция.Удалить(УдаляемаяСтрока);
		КонецЦикла;

	ИначеЕсли ТипКоллекции = Тип("ДеревоЗначений") Тогда
		МассивУзловКУдалению = Коллекция.Строки.НайтиСтроки(Поиск, Истина);
		Для каждого УзелКоллекции Из МассивУзловКУдалению Цикл
			РодительУзла = УзелКоллекции.Родитель;
			Если РодительУзла =Неопределено Тогда
				РодительУзла = Коллекция;
			КонецЕсли;
			РодительУзла.Строки.Удалить(УзелКоллекции);
		КонецЦикла;

	Иначе
		 ВызватьИсключение("Передан неподдерживаемый тип " + ТипКоллекции);

	КонецЕсли;

	Если УдалитьФлаговуюКолонку Тогда
		Коллекция.Колонки.Удалить(ИмяФлаговойКолонки);
	КонецЕсли;

КонецПроцедуры

Функция ПеремешатьЗначения(Список) Экспорт

	ТаблицаПеремешивания = Новый ТаблицаЗначений;
	ТаблицаПеремешивания.Колонки.Добавить("Значение");
	ТаблицаПеремешивания.Колонки.Добавить("Порядок");

	Для каждого Элем Из Список Цикл
		СтрокаТаблицы = ТаблицаПеремешивания.Добавить();
		СтрокаТаблицы.Значение = Элем;
		СтрокаТаблицы.Порядок = Новый УникальныйИдентификатор;
	КонецЦикла;

	ТаблицаПеремешивания.Сортировать("Порядок");

	Возврат ТаблицаПеремешивания.ВыгрузитьКолонку("Значение");

КонецФункции

Функция ПредставлениеВремени(ВремяВСекундах) Экспорт
	чч = Цел(ВремяВСекундах / 3600);
	мм = Цел((ВремяВСекундах - чч * 3600) / 60);
	сс = ВремяВСекундах - чч * 3600 - мм * 60;

	ФСтрока = "ЧЦ=2; ЧДЦ=0; ЧН=00; ЧВН=";

	Результат = СтрШаблон("%1:%2:%3"
		, Формат(чч, ФСтрока)
		, Формат(мм, ФСтрока)
		, Формат(сс, ФСтрока));

	Возврат Результат;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Выполняет поиск проверяемых выражений среди реквизитов объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя проверяемого объекта.
//  ПроверяемыеВыражения       - Массив - имена полей или проверяемые выражения объекта метаданных.
//
// Возвращаемое значение:
//  Структура - Результат проверки.
//  * Ошибка         - Булево - Найдена ошибка.
//  * ОписаниеОшибки - Строка - Описание найденных ошибок.
//
// Пример:
//
// Реквизиты = Новый Массив;
// Реквизиты.Добавить("Номер");
// Реквизиты.Добавить("Валюта.НаименованиеПолное");
//
// Результат = ОбщегоНазначения.НайтиОшибкуДоступностиРеквизитовОбъекта("Документ._ДемоЗаказПокупателя", Реквизиты);
//
// Если Результат.Ошибка Тогда
//     ВызватьИсключение Результат.ОписаниеОшибки;
// КонецЕсли;
//
Функция НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения)

	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);

	Если МетаданныеОбъекта = Неопределено Тогда
		Возврат Новый Структура("Ошибка, ОписаниеОшибки", Истина,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка получения метаданных ""%1""'"), ПолноеИмяОбъектаМетаданных));
	КонецЕсли;

	// Разрешение вызова из безопасного режима внешней обработки или расширения.
	// Информация о доступности полей источника схемы при проверке метаданных не является секретной.
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);

	Схема = Новый СхемаЗапроса;
	Пакет = Схема.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = Пакет.Операторы.Получить(0);

	Источник = Оператор.Источники.Добавить(ПолноеИмяОбъектаМетаданных, "Таблица");
	ТекстОшибки = "";

	Для Каждого ТекущееВыражение Из ПроверяемыеВыражения Цикл

		Если Не ПолеИсточникаСхемыЗапросаДоступно(Источник, ТекущееВыражение) Тогда
			ТекстОшибки = ТекстОшибки + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = '- Поле объекта ""%1"" не найдено'"), ТекущееВыражение);
		КонецЕсли;

	КонецЦикла;

	Возврат Новый Структура("Ошибка, ОписаниеОшибки", Не ПустаяСтрока(ТекстОшибки), ТекстОшибки);

КонецФункции

// Используется в НайтиОшибкуДоступностиРеквизитовОбъекта.
// Выполняет проверку доступности поля проверяемого выражения в источнике оператора схемы запроса.
//
Функция ПолеИсточникаСхемыЗапросаДоступно(ИсточникОператора, ПроверяемоеВыражение)

	ЧастиИмениПоля = СтрРазделить(ПроверяемоеВыражение, ".");
	ДоступныеПоля = ИсточникОператора.Источник.ДоступныеПоля;

	ТекущаяЧастьИмениПоля = 0;
	Пока ТекущаяЧастьИмениПоля < ЧастиИмениПоля.Количество() Цикл

		ТекущееПоле = ДоступныеПоля.Найти(ЧастиИмениПоля.Получить(ТекущаяЧастьИмениПоля));

		Если ТекущееПоле = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;

		// Инкрементация следующей части имени поля и соответствующего списка доступности полей.
		ТекущаяЧастьИмениПоля = ТекущаяЧастьИмениПоля + 1;
		ДоступныеПоля = ТекущееПоле.Поля;

	КонецЦикла;

	Возврат Истина;

КонецФункции

#КонецОбласти
